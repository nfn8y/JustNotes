package com.nfn8y.notesapp.common.repository

import app.cash.sqldelight.coroutines.asFlow
import app.cash.sqldelight.coroutines.mapToList
import com.nfn8y.notesapp.common.model.Note
import com.nfn8y.notesapp.db.AppDatabase
import com.nfn8y.notesapp.db.NoteEntityQueries
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.IO
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.map
import kotlinx.coroutines.withContext
import kotlinx.datetime.Instant

class SqlDelightNoteRepository(
    private val database: AppDatabase // Pass the generated AppDatabase
) : NoteRepository {

    private val queries: NoteEntityQueries = database.noteEntityQueries

    // Helper to convert NoteEntity (generated by SQLDelight) to common Note model
    private fun NoteEntity.toNote(): Note = Note(
        id = this.id,
        title = this.title,
        content = this.content,
        createdAt = this.createdAt, // Assumes adapter handles Instant
        updatedAt = this.updatedAt  // Assumes adapter handles Instant
    )

    override fun getAllNotesFlow(): Flow<List<Note>> {
        return queries.selectAll()
            .asFlow()
            .mapToList(Dispatchers.IO) // Use Dispatchers.IO for database operations
            .map { noteEntities ->
                noteEntities.map { it.toNote() }
            }
    }

    override suspend fun getNoteById(id: Long): Note? {
        return withContext(Dispatchers.IO) {
            queries.selectById(id).executeAsOneOrNull()?.toNote()
        }
    }

    override suspend fun addNote(title: String, content: String): Note {
        val now = kotlinx.datetime.Clock.System.now()
        return withContext(Dispatchers.IO) {
            queries.transactionWithResult {
                queries.insert(
                    title = title,
                    content = content,
                    createdAt = now,
                    updatedAt = now
                )
                val lastId = queries.getInsertId().executeAsOne()
                Note(
                    id = lastId,
                    title = title,
                    content = content,
                    createdAt = now,
                    updatedAt = now
                )
            }
        }
    }

    override suspend fun updateNote(note: Note) {
        if (note.id == null) return // Cannot update a note without an ID
        val now = kotlinx.datetime.Clock.System.now()
        withContext(Dispatchers.IO) {
            queries.updateById(
                id = note.id,
                title = note.title,
                content = note.content,
                updatedAt = now // Update timestamp
            )
        }
    }

    override suspend fun deleteNoteById(id: Long) {
        withContext(Dispatchers.IO) {
            queries.deleteById(id)
        }
    }
}