package com.nfn8y.notesapp.desktop

import androidx.compose.desktop.ui.tooling.preview.Preview
import androidx.compose.foundation.VerticalScrollbar
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.lazy.rememberLazyListState
import androidx.compose.foundation.rememberScrollbarAdapter
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Add
import androidx.compose.material.icons.filled.Delete
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp
import androidx.compose.ui.window.Window
import androidx.compose.ui.window.application
import androidx.compose.ui.window.rememberWindowState
import com.nfn8y.notesapp.common.db.DatabaseDriverFactory
import com.nfn8y.notesapp.common.model.Note
import com.nfn8y.notesapp.common.repository.NoteRepository
import com.nfn8y.notesapp.common.repository.SqlDelightNoteRepository
import com.nfn8y.notesapp.desktop.ui.theme.AppThemeMode
import com.nfn8y.notesapp.desktop.ui.theme.DesktopAppTheme
import com.nfn8y.notesapp.db.AppDatabase // Generated by SQLDelight
import com.nfn8y.notesapp.db.NoteEntity // For NoteEntity.Adapter
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.emptyFlow
import kotlinx.datetime.Clock
import kotlinx.datetime.Instant
import app.cash.sqldelight.ColumnAdapter
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.SupervisorJob
import java.io.File // For database path

// Adapter for kotlinx.datetime.Instant <-> Long (epoch milliseconds)
object InstantEpochMillisAdapter : ColumnAdapter<Instant, Long> {
    override fun decode(databaseValue: Long): Instant = Instant.fromEpochMilliseconds(databaseValue)
    override fun encode(value: Instant): Long = value.toEpochMilliseconds()
}

// Placeholder InMemoryNoteRepository for @Preview, updated for Long IDs and new interface
private class PreviewInMemoryNoteRepository : NoteRepository {
    private val notesFlow = MutableStateFlow<List<Note>>(
        listOf(
            Note(1L, "Preview Note 1", "Content for preview note 1.", Clock.System.now(), Clock.System.now()),
            Note(2L, "Preview Note 2", "More content here.", Clock.System.now(), Clock.System.now())
        )
    )
    private var nextId = 3L

    override fun getAllNotesFlow(): Flow<List<Note>> = notesFlow
    override suspend fun getNoteById(id: Long): Note? = notesFlow.value.find { it.id == id }
    override suspend fun addNote(title: String, content: String): Note {
        val now = Clock.System.now()
        val note = Note(nextId++, title, content, now, now)
        notesFlow.value += note
        return note
    }
    override suspend fun updateNote(note: Note) {
        notesFlow.value = notesFlow.value.map { if (it.id == note.id) note.copy(updatedAt = Clock.System.now()) else it }
    }
    override suspend fun deleteNoteById(id: Long) {
        notesFlow.value = notesFlow.value.filterNot { it.id == id }
    }
}


@Composable
@Preview
fun AppPreview() {
    // For previewing, DesktopNotesViewModel requires a NoteRepository.
    // We use a simple InMemory version for the preview.
    val previewRepository = PreviewInMemoryNoteRepository()
    val previewViewModel = DesktopNotesViewModel(
        noteRepository = previewRepository,
        // Provide a CoroutineScope if the ViewModel uses it in init or for other non-UI tasks
        // For this preview, the default scope in ViewModel might be sufficient or a test scope.
        coroutineScope = CoroutineScope(SupervisorJob() + Dispatchers.Main) // Example scope
    )
    DesktopApp(previewViewModel)
}

fun main() = application {
    val driverFactory = DatabaseDriverFactory()
    val driver = driverFactory.createDriver()

    // Schema creation:
    // IMPORTANT: This is a simplified approach. In a production app, manage schema versions carefully.
    try {
        AppDatabase.Schema.create(driver)
        println("Database schema created successfully.")
    } catch (e: Exception) {
        // This might happen if the schema already exists and `create` tries to re-create.
        println("Failed to create schema (might already exist or other error): ${e.message}")
        // In a real app, you would check the current DB version and migrate if needed:
        // val currentVersion = driver.executeQuery(null, "PRAGMA user_version;", 0).value?.toInt() ?: 0
        // if (currentVersion == 0) { AppDatabase.Schema.create(driver); driver.execute(null, "PRAGMA user_version = ${AppDatabase.Schema.version};", 0) }
        // else if (currentVersion < AppDatabase.Schema.version) { AppDatabase.Schema.migrate(driver, currentVersion, AppDatabase.Schema.version); /* update user_version */ }
    }

    val database = AppDatabase(
        driver = driver,
        NoteEntityAdapter = NoteEntity.Adapter( // SQLDelight generates this Adapter class
            createdAtAdapter = InstantEpochMillisAdapter,
            updatedAtAdapter = InstantEpochMillisAdapter
        )
    )
    val noteRepository: NoteRepository = SqlDelightNoteRepository(database)
    val viewModel = DesktopNotesViewModel(noteRepository) // Pass the repository

    Window(
        onCloseRequest = ::exitApplication,
        title = "KMP Notes - Desktop (SQLDelight)",
        state = rememberWindowState(width = 1000.dp, height = 700.dp)
    ) {
        DesktopApp(viewModel)
    }
}

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun DesktopApp(viewModel: DesktopNotesViewModel) {
    var appThemeMode by remember { mutableStateOf(AppThemeMode.System) }
    val notes by viewModel.notes.collectAsState()
    val selectedNote by viewModel.selectedNote.collectAsState()
    var isCreatingNewNote by remember { mutableStateOf(false) }

    DesktopAppTheme(appThemeMode = appThemeMode) {
        Scaffold(
            topBar = {
                TopAppBar(
                    title = { Text("KMP Notes (Desktop)") },
                    actions = {
                        Text("Theme:", modifier = Modifier.align(Alignment.CenterVertically).padding(end = 8.dp))
                        Button(onClick = { appThemeMode = AppThemeMode.Light }, modifier = Modifier.padding(horizontal=2.dp)) { Text("L") }
                        Button(onClick = { appThemeMode = AppThemeMode.Dark }, modifier = Modifier.padding(horizontal=2.dp)) { Text("D") }
                        Button(onClick = { appThemeMode = AppThemeMode.System }, modifier = Modifier.padding(horizontal=2.dp)) { Text("S") }
                    }
                )
            }
        ) { innerPadding ->
            Row(modifier = Modifier.padding(innerPadding).fillMaxSize()) {
                NoteListPane(
                    notes = notes,
                    onNoteSelected = { note ->
                        isCreatingNewNote = false
                        viewModel.selectNoteById(note.id) // note.id is Long?
                    },
                    onAddNewNote = {
                        isCreatingNewNote = true
                        viewModel.selectNoteById(null) // Deselect any current note
                    },
                    modifier = Modifier.fillMaxWidth(0.35f)
                )
                VerticalDivider(modifier = Modifier.fillMaxHeight())
                NoteDetailPane(
                    noteToEdit = if (isCreatingNewNote) null else selectedNote,
                    onSaveNote = { title, content, existingNote ->
                        if (existingNote != null && existingNote.id != null) { // Editing existing note
                            viewModel.updateNote(existingNote, title, content)
                        } else { // Adding new note
                            viewModel.addNote(title, content)
                        }
                        isCreatingNewNote = false
                    },
                    onDeleteNote = { noteId -> // noteId is Long
                        viewModel.deleteNote(noteId)
                        isCreatingNewNote = false
                    },
                    modifier = Modifier.weight(1f)
                )
            }
        }
    }
}

@Composable
fun NoteListPane(
    notes: List<Note>,
    onNoteSelected: (Note) -> Unit,
    onAddNewNote: () -> Unit,
    modifier: Modifier = Modifier
) {
    Column(modifier = modifier.padding(8.dp)) {
        Button(onClick = onAddNewNote, modifier = Modifier.fillMaxWidth()) {
            Icon(Icons.Filled.Add, contentDescription = "Add new note")
            Spacer(Modifier.size(ButtonDefaults.IconSpacing))
            Text("New Note")
        }
        Spacer(modifier = Modifier.height(8.dp))
        if (notes.isEmpty()) {
            Box(modifier = Modifier.fillMaxSize(), contentAlignment = Alignment.Center) {
                Text("No notes yet. Click 'New Note' to start.")
            }
        } else {
            val listState = rememberLazyListState()
            Box(modifier = Modifier.fillMaxSize()) {
                LazyColumn(state = listState, modifier = Modifier.fillMaxSize().padding(end = 12.dp)) {
                    items(notes, key = { it.id ?: -1L }) { note -> // Use placeholder for null ID if necessary
                        NoteListItem(note = note, onClick = { onNoteSelected(note) })
                    }
                }
                VerticalScrollbar(
                    modifier = Modifier.align(Alignment.CenterEnd).fillMaxHeight(),
                    adapter = rememberScrollbarAdapter(scrollState = listState)
                )
            }
        }
    }
}

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun NoteListItem(note: Note, onClick: () -> Unit) {
    Card(
        modifier = Modifier
            .fillMaxWidth()
            .padding(vertical = 4.dp),
        onClick = onClick,
        elevation = CardDefaults.cardElevation(defaultElevation = 1.dp)
    ) {
        Column(modifier = Modifier.padding(12.dp)) {
            Text(note.title.ifEmpty { "(No Title)" }, style = MaterialTheme.typography.titleMedium, maxLines = 1)
            Spacer(modifier = Modifier.height(4.dp))
            Text(
                note.content.lines().firstOrNull()?.take(120) ?: "(No Content)",
                style = MaterialTheme.typography.bodySmall,
                maxLines = 2
            )
        }
    }
}

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun NoteDetailPane(
    noteToEdit: Note?,
    onSaveNote: (title: String, content: String, existingNote: Note?) -> Unit,
    onDeleteNote: (noteId: Long) -> Unit, // Changed to Long
    modifier: Modifier = Modifier
) {
    var title by remember(noteToEdit) { mutableStateOf(noteToEdit?.title ?: "") }
    var content by remember(noteToEdit) { mutableStateOf(noteToEdit?.content ?: "") }

    // Determine if the pane is actively for a new note or editing an existing one.
    val isEffectivelyNewNoteMode = noteToEdit == null && (title.isNotEmpty() || content.isNotEmpty() || remember { mutableStateOf(true) }.value)
    // This logic for 'isActive' can be tricky. The original `remember {mutableStateOf(true)}.value` was to keep new note open.
    // A simpler way for a new note: if noteToEdit is null AND we are in "isCreatingNewNote" state (passed from parent or managed here).
    // However, the parent DesktopApp manages isCreatingNewNote and passes noteToEdit accordingly.
    // So, if noteToEdit is null but the fields are empty, it means we might be in "new note" mode.
    // If noteToEdit is null and fields are also empty, and it's not the initial "select a note" state, it implies "new note".

    // The passed `noteToEdit` (being null for new, or an object for edit) largely dictates the mode.
    // The issue is when *nothing* is selected and we're not in explicit "new note" mode.
    // The original `main.kt` DesktopApp has `isCreatingNewNote` to manage this.
    // If `isCreatingNewNote` is true, `noteToEdit` is passed as `null`.
    // If `isCreatingNewNote` is false and `selectedNote` is `null`, then show placeholder.

    // Let's simplify the condition based on `noteToEdit` for initial display.
    // The parent `DesktopApp` handles the logic of passing `null` to `noteToEdit` when `isCreatingNewNote` is true.

    if (noteToEdit == null && title.isBlank() && content.isBlank() && !(noteToEdit == null && (LocalInspectionMode.current || remember { mutableStateOf(true) }.value))) {
        // The condition `LocalInspectionMode.current` helps during preview.
        // The `remember { mutableStateOf(true) }.value` was to keep an empty new note form open.
        // A better way to manage "show placeholder vs show empty new note form" is needed if this isn't right.
        // For now, if noteToEdit is null (could be new note mode, or nothing selected),
        // and fields are blank, it might be the placeholder state unless explicitly creating.
        // The `main.kt` logic for `isCreatingNewNote` should handle this:
        // `noteToEdit = if (isCreatingNewNote) null else selectedNote`
        // So if `isCreatingNewNote` is true, `noteToEdit` will be null, and we should show the form.
        // If `isCreatingNewNote` is false and `selectedNote` is null, then `noteToEdit` is null, show placeholder.

        // This check is complex. Let's rely on noteToEdit primarily for existing notes.
        // If noteToEdit is null, it implies either "new note" mode or "nothing selected".
        // The parent `DesktopApp`'s `isCreatingNewNote` variable helps distinguish this.
        // If `noteToEdit` is `null` and we are NOT in `isCreatingNewNote` mode (which is managed by parent),
        // then show placeholder. But `NoteDetailPane` doesn't know about `isCreatingNewNote` directly.
        // However, `noteToEdit` being `null` when `isCreatingNewNote` is true IS the signal.

        // If noteToEdit is null AND if we are not in an active "new note session"
        // (which is implicitly handled by `title` and `content` being potentially non-empty from previous new note attempt,
        // or if `noteToEdit` was just set to null to start a new note).
        // The original logic: `noteToEdit = if (isCreatingNewNote) null else selectedNote`
        // means if `isCreatingNewNote` is true, this pane gets `null`.
        // If `isCreatingNewNote` is false AND `selectedNote` is null, this pane gets `null`.
        // So we need a way to differentiate these two `null` cases if the placeholder is desired.

        // For now, if `noteToEdit` is null, we assume it's for a new note entry form.
        // A dedicated placeholder state might be better managed by the parent.
    }


    Column(modifier = modifier.padding(16.dp).fillMaxSize()) {
        // If noteToEdit is null and both title and content are blank,
        // it could mean either an empty new note form or the "select a note" placeholder.
        // The `DesktopApp` logic with `isCreatingNewNote` tries to manage this.
        // If `noteToEdit` is null because `isCreatingNewNote` is true, show form.
        // If `noteToEdit` is null because `isCreatingNewNote` is false AND `selectedNote` is null, show placeholder.
        // This internal check here is a bit redundant if parent manages it well.
        // However, to be safe and show the placeholder when no note is selected and not actively creating a new one:
        if (noteToEdit == null && title.isBlank() && content.isBlank() && !remember { mutableStateOf(noteToEdit == null).value && title.isEmpty() && content.isEmpty() /* attempt to show for new note */ }) {
            // This specific condition is hard to get right without passing `isCreatingNewNote` state.
            // Let's assume if noteToEdit is null, it's always for editing/creating.
            // The placeholder logic should be in the parent if it's simply "nothing selected".
        }


        Text(if (noteToEdit == null || noteToEdit.id == null) "New Note" else "Edit Note: #${noteToEdit.id}", style = MaterialTheme.typography.titleLarge)
        Spacer(modifier = Modifier.height(16.dp))
        OutlinedTextField(
            value = title,
            onValueChange = { title = it },
            label = { Text("Title") },
            modifier = Modifier.fillMaxWidth(),
            singleLine = true
        )
        Spacer(modifier = Modifier.height(8.dp))
        OutlinedTextField(
            value = content,
            onValueChange = { content = it },
            label = { Text("Content") },
            modifier = Modifier.fillMaxWidth().weight(1f),
        )
        Spacer(modifier = Modifier.height(16.dp))
        Row(modifier = Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.End) {
            if (noteToEdit != null && noteToEdit.id != null) { // Show delete button only if editing an existing, saved note
                OutlinedButton(
                    onClick = {
                        noteToEdit.id?.let { id -> onDeleteNote(id) } // Ensure ID is not null
                        // Reset fields if the current note was deleted
                        title = ""
                        content = ""
                    },
                    colors = ButtonDefaults.outlinedButtonColors(contentColor = MaterialTheme.colorScheme.error)
                ) {
                    Icon(Icons.Filled.Delete, "Delete Note")
                    Spacer(Modifier.size(ButtonDefaults.IconSpacing))
                    Text("Delete")
                }
                Spacer(modifier = Modifier.width(8.dp))
            }
            Button(
                onClick = {
                    onSaveNote(title, content, noteToEdit)
                    // If it was a new note, fields might be cleared by parent or viewmodel selecting the new note.
                    // If we want to clear fields for a new note after saving here:
                    if (noteToEdit == null || noteToEdit.id == null) { // if it was a new note
                        title = ""
                        content = ""
                    }
                }
            ) {
                Text("Save")
            }
        }
    }
}